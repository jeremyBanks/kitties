<!doctype html>

<!-- styles -->
<style>
body {
    font-family: Verdana, sans-serif;
    margin: 32px;
}

input, button {
    font: inherit;
    padding: 2px 6px;
}

a {
    text-decoration: none;
    color: inherit;
}

p, ol, ul, li {
    margin: 0;
}

ul {
    margin-left: 128px;
    margin-bottom: 8px;
    border-left: 1px solid black;
    list-style-type: square;
    padding-left: 16px;
}

li {
    padding: 2px;
}

form {
    margin-bottom: 32px;
}

a.kitty {
    border-bottom: 1px solid black;
    margin-right: -16px;
    margin-left: -18px;
}


a.kitty {
    --kitty-size: 192px;
    --text-size: calc(var(--kitty-size) / 16);
    --name-color: black;
    --info-color: #444;
    --text-shadow-color: rgba(255, 255, 255, 0.5);

    display: inline-block;
    position: relative;
    vertical-align: middle;
    box-sizing: border-box;
    width: calc(var(--kitty-size) * 12/16);
    height: calc(var(--kitty-size) * 10/16);

    text-decoration: none;
    color: var(--text-color);
    font: var(--text-size) monospace;
    user-select: all;
}

a.kitty > * {
    display: block;
    position: absolute;
    box-sizing: border-box;
    height: auto;
}

a.kitty > img {
    pointer-events: none;
    width: var(--kitty-size);
    height: var(--kitty-size);
    top: calc(var(--kitty-size) * -3/16);
    left: calc(var(--kitty-size) * -3/16);
}

a.kitty > .name {
    font-family: verdana, sans-serif;
    height: auto;
    right: calc(var(--text-size));
    bottom: var(--text-size);
    text-align: center;
    font-weight: bold;
    color: var(--name-color);
    text-shadow:
        0 0 3px var(--text-shadow-color),
        2px 0 3px var(--text-shadow-color),
        2px 2px 3px var(--text-shadow-color),
        0 2px 3px var(--text-shadow-color),
        -2px 2px 3px var(--text-shadow-color),
        -2px 0 3px var(--text-shadow-color),
        -2px -2px 3px var(--text-shadow-color),
        0 -2px 3px var(--text-shadow-color),
        2px -2px 3px var(--text-shadow-color);
}

a.kitty > .info {
    bottom: 0;
    right: 0;
    color: var(--info-color);
    text-shadow:
        0 0 3px var(--text-shadow-color),
        2px 0 3px var(--text-shadow-color),
        2px 2px 3px var(--text-shadow-color),
        0 2px 3px var(--text-shadow-color),
        -2px 2px 3px var(--text-shadow-color),
        -2px 0 3px var(--text-shadow-color),
        -2px -2px 3px var(--text-shadow-color),
        0 -2px 3px var(--text-shadow-color),
        2px -2px 3px var(--text-shadow-color);
}

a.kitty:hover > .name, a.kitty:hover > .info {
    color: transparent;
    --text-shadow-color: rgba(64, 64, 64, 0.125);
}
</style>


<!-- layout -->
<main>
    <form id="family">
        <p>
            <label>Owner Address <input name="owner-address" placeholder='0x12345678...' /></label>
            <button type="submit">Show</button>
        </p>
    </form>

    <div id="output">

    </div>
</main>


<!-- inline module shim -->
<!-- this is a goofy hack, but external modules don't work
     in file:// URLs, and I'd like this to work locally. -->
<script type="module" data-info="https://stackoverflow.com/a/43834063">let l,e,t
='script',p=/(from\s+|import\s+)['"](#[\w\-]+)['"]/g,x='textContent',d=document,
s,o;for(o of d.querySelectorAll(t+'[type=inline-module]'))l=d.createElement(t),o
.id?l.id=o.id:0,l.type='module',l[x]=o[x].replace(p,(u,a,z)=>(e=d.querySelector(
t+z+'[type=module][src]'))?a+`/* ${z} */'${e.src}'`:u),l.src=URL.createObjectURL
(new Blob([l[x]],{type:'application/java'+t})),o.replaceWith(l)//inline</script>


<!-- dom utils -->
<script type="inline-module" id="dom">
export const el = (tagNamesString, ...childrenAndAttributes) => {
    let outer, inner;
    if (!tagNamesString) {
        // If the user tries to set attributes on this, should be an error.
        outer = inner = document.createDocumentFragment();
    } else {
        const tagNames = tagNamesString.split(' ');
        outer = inner = document.createElement(tagNames[0]);
        for (const innerTagName of tagNames.slice(1)) {
            const newInner = document.createElement(innerTagName);
            inner.appendChild(newInner);
            inner = newInner;
        }
    }

    addToElement(inner, childrenAndAttributes);

    return outer;
};

el.setChildren = (parent, ...children) => {
    const newContents = el('', ...children);
    parent.textContent = '';
    parent.appendChild(newContents);
};

el.TO_EL = Symbol('el.TO_EL');

const addToElement = (element, additions, before) => {
    if (before) element = before.parentElement; // hacky fix for documentfragment parents and promises

    for (const childOrAttributes of additions) {
        if (Array.isArray(childOrAttributes)) {
            addToElement(element, childOrAttributes, before);
        } else if (childOrAttributes instanceof Node) {
            element.insertBefore(childOrAttributes, before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes[el.TO_EL] == 'function'
        ) {
            const additions = el('', childOrAttributes[el.TO_EL]());
            addToElement(element, [additions], before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes.then == 'function'
        ) {
            const placeholder = document.createComment(' Promise pending. ');
            element.insertBefore(placeholder, before);
            childOrAttributes.then(additions => {
                placeholder.textContent = ' Promise resolved. ';
                addToElement(element, [additions], placeholder)
            }, error => {
                placeholder.textContent = ` Promise rejected: ${error && error.stack || error} `;
                console.error(error);
            });
        } else if (typeof childOrAttributes == 'object') {
            if (!(element instanceof Element)) {
                throw new Error("el() cannot define attributes without an element type.");
            }
            for (const key of Object.keys(childOrAttributes)) {
                element.setAttribute(key, childOrAttributes[key]);
            }
        } else if (childOrAttributes != null) {
            element.insertBefore(document.createTextNode(String(childOrAttributes)), before);
        }
    }
};
</script>


<!-- async utils -->
<script type="inline-module" id="async">
export class Throttle {
    constructor(minInterval = 1000) {
        this.minInterval = minInterval;
        this.next = Promise.resolve();
    }

    async tick() {
        const current = this.next;
        this.next = current.then(_ => new Promise(r => setTimeout(r, this.minInterval)));
        return current;
    }
}
</script>


<!-- cryptokitties web API -->
<script type="inline-module" id="cryptokitties">
import {Throttle} from '#async';

export class CryptoKitties {
    constructor() {
        this.apiRoot_ = 'https://api.cryptokitties.co/';
        this.apiThrottle_ = new Throttle(256);
    }

    async fetch_(path) {
        await this.apiThrottle_.tick();
        const response = await fetch(this.apiRoot_ + path);
        if (!response.ok) {
            throw new Error("non-ok response from cryptokitties API");
        }
        const json = await response.json();
        return json;
    }

    async *kitties(ownerAddress='', search='', offset=0, limit=Infinity) {
        const kitties = [];
        for (;;) {
            const page = await this.kitties_(
                ownerAddress, offset + kitties.length, Math.min(100, limit - kitties.length), false, search);

            for (const kitty of page.kitties) {
                kitties.push(kitty);
                yield await Kitty.fetch(kitty.id);
            }

            if (kitties.length >= limit) {
                // reached limit
                break;
            }

            if (kitties.length >= page.kitties.total) {
                // last page
                break;
            }

            if (page.kitties.length === 0) {
                // past last page
                break;
            }
        }
    }

    async kitties_(ownerAddress='', offset=0, limit=100, parents=false, search='') {
        return this.fetch_(`kitties?owner_wallet_address=${ownerAddress}&offset=${offset}&limit=${limit}&parents=${parents}&search=${search}`);
    }

    async kitty(kittyId) {
        return this.fetch_(`kitties/${kittyId}`);
    }
};

export const cryptokitties = new CryptoKitties();
export default cryptokitties;

export class Kitty {
    constructor() {
        this.id = -1;
        this.name = '⚠ uninitialized ⚠';
        this.generation = -1;
        this.children = null;
        this.matron = null;
        this.sire = null;
    }

    static async fetch(kittyId) {
        const key = `Kitty/${kittyId}`;
        let data = null;

        for (const stored of [
            Kitty.cache.get(key),
            window.localStorage.getItem(key), 
        ]) {
            if (!stored) {
                continue;
            }

            const {data: storedData, timestamp} = JSON.parse(stored);
            if (Date.now() < timestamp + 1000 * 32) {
                data = storedData;
                break;
            }
        }

        if (!data) {
            data = await cryptokitties.kitty(kittyId);

            const storable = JSON.stringify({
                data: data,
                timestamp: Date.now() + Math.random() * 1000 * 512,
            });

            Kitty.cache.set(key, storable);
            try {
                localStorage.setItem(key, storable);
            } catch (ex) {
                console.error(ex);
                console.error("clearing localStorage");
                localStorage.clear();
            }
        }
        
        return Object.assign(new Kitty(), data);
    }

    get owner_wallet_address() {
        return this.owner && this.owner.address;
    }

    get owner_name() {
        return this.owner && this.owner.nickname;
    }
    
    get parent_ids() {
        const ids = [];
        if (this.matron) ids.push(this.matron.id);
        if (this.sire) ids.push(this.sire.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }
    
    get child_ids() {
        const ids = this.children.map(kitty => kitty.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }
}

Kitty.cache = new Map();
</script>


<!-- our logic -->
<script type="inline-module" id="tree">
import {el} from '#dom';
import {cryptokitties, Kitty} from '#cryptokitties';

const form = document.querySelector('form#family');
const ownerAddressEl = form.querySelector('[name=owner-address]');
const output = document.querySelector('#output');

export const main = async () => {
    if (location.search.match(/^\?owner\-address=.+$/)) {
        const ownerAddress = decodeURIComponent(location.search.slice('?owner-address='.length));

        ownerAddressEl.value = ownerAddress;

        if (ownerAddress) {
            for await (const kitty of cryptokitties.kitties(ownerAddress, 'gen:0 selkirk')) {
                output.appendChild(el('', makeTree(kitty)));

                await new Promise(resolve => setTimeout(resolve, 2500));
            }
        }
    }
};

const makeTree = async (kitty, rootKitty = kitty) => {
    const renderKitty = (kitty) => {
        let className = 'kitty'

        if (kitty.owner_wallet_address !== rootKitty.owner_wallet_address) {
            className += ' unrelated';
        }

        return el(
            'a',
            {
                class: className,
                href: `https://www.cryptokitties.co/kitty/${kitty.id}`
            },
            el(
                'img',
                {
                    src: kitty.image_url
                }
            ),
            el('span', {class: 'info'}, `k${kitty.id} g${kitty.generation} c${kitty.children.length}`),
            el('span', {class: 'name'}, `${kitty.name}`),
        );
    };

    const children = await Promise.all(kitty.child_ids.map(id => Kitty.fetch(id)));
    const partner_ids = new Set();
    for (const child of children) {
        for (const parentId of child.parent_ids) {
            partner_ids.add(parentId);
        }
    }
    partner_ids.delete(kitty.id);

    const partners = await Promise.all([...partner_ids].sort().map(id => Kitty.fetch(id)));

    if (partners.length == 0) {
        // no children. easy.
        return el('p', renderKitty(kitty));
    } else if (partners.length == 1) {
        // monogamy. easy!
        return el('p', renderKitty(kitty), ' + ', renderKitty(partners[0]), el('ul', children.map(child => el('li', makeTree(child, rootKitty)))));
    } else {
        // polygamy. easy?
        return el('p', renderKitty(kitty),
            partners.map(partner => el(
                'p', '+ ', renderKitty(partner),
                el('ul', children.filter(child => child.parent_ids.includes(partner.id)).map(child => el('li', makeTree(child, rootKitty)))))));
    }
};
</script>


<!-- entry point -->
<script type="inline-module">
import { Kitty } from '#cryptokitties';
import { main } from '#tree';

setTimeout(main);

window.Kitty = Kitty;
</script>
