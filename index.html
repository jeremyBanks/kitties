<!doctype html>

<title>CryptoKitty Family Trees</title>

<link rel="icon" href="data:,">

<main>
    <form id="family">
        <p>
            <label>Owner Address: <input name="owner-address" placeholder='0x1234567890123456789012345678901234567890' /></label>
            <button type="submit">Show</button>
        </p>
    </form>

    <div id="output">

    </div>
</main>


<!-- styles -->
<style>
body {
    font-family: Verdana, sans-serif;
    margin: 32px;
    margin-bottom: 512px;
}

progress {
    width: 1em;
    height: 1em;
}

input, button, label {
    font-family: monospace;
    padding: 2px 6px;
}

input[name="owner-address"] {
    width: 50ex;
}

p, ol, ul, li {
    margin: 0;
}

ul {
    margin-left: 128px;
    margin-bottom: 8px;
    border-left: 1px solid black;
    list-style-type: square;
    padding-left: 16px;
}

li {
    padding: 2px;
}

form {
    margin-bottom: 32px;
}

.poly {
    border-left: 1px dashed black;
}

a.kitty > span.gene {
    font: 12px Consolas, monospace;
    font-weight: bold;
    text-align: right;
    left: auto;
    top: 50px;
    right: 8px;
    bottom: auto;
}

a.kitty {
    animation-name: appear;
    animation-duration: 0.5s;
    border-bottom: 1px solid black;
    margin-right: -16px;
    margin-left: -18px;
}
@keyframes appear {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

a.kitty > img {
    animation-name: appear-fancy;
    animation-duration: 0.5s;

}
@keyframes appear-fancy {
    0% {
        transform: scale(0);
    }
    50% {
        transform: scale(0);
    }
    75% {
        transform: scale(1);
    }
}



a.kitty {
    --kitty-size: 192px;
    --text-size: calc(var(--kitty-size) / 16);
    --name-color: black;
    --info-color: #444;
    --text-shadow-color: rgba(255, 255, 255, 0.5);

    display: inline-block;
    position: relative;
    vertical-align: middle;
    box-sizing: border-box;
    width: calc(var(--kitty-size) * 12/16);
    height: calc(var(--kitty-size) * 10/16);

    text-decoration: none;
    color: var(--text-color);
    font: var(--text-size) monospace;
    user-select: all;
}

a.kitty.repeated > * {
    --name-color: royalblue;
    --info-color: royalblue;
}
a.kitty.repeated > img {
    opacity: 0.25;
}
a.kitty.repeated > img {
    opacity: 0.25;
}

a.kitty.unrelated {
    --name-color: brown;
    --info-color: brown;
}
a.kitty.unrelated > img {
    opacity: 0.25;
}

a.kitty:target, a.kitty:active {
    animation-name: fade-highlight-background;
    animation-duration: 3s;
    animation-fill-mode: forwards;

}
@keyframes fade-highlight-background {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        background: rgba(255, 255, 255, 0);
    }
    10% {
        box-shadow: 0 0 6px 6px #FF0;
        background: #FF0;
    }
    20% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        background: rgba(255, 255, 255, 0);
    }
    30% {
        box-shadow: 0 0 6px 6px #FF0;
        background: #FF0;
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.25);
        background: rgba(255, 255, 0, 0.25);
    }
}

a.kitty > * {
    display: block;
    position: absolute;
    box-sizing: border-box;
    height: auto;
}

a.kitty > img {
    pointer-events: none;
    width: var(--kitty-size);
    height: var(--kitty-size);
    top: calc(var(--kitty-size) * -3/16);
    left: calc(var(--kitty-size) * -3/16);
}

a.kitty > .name, a.kitty > .gene {
    left: 0;
    font-family: verdana, sans-serif;
    height: auto;
    overflow-wrap: break-word;
    right: calc(var(--text-size));
    bottom: var(--text-size);
    text-align: center;
    font-weight: bold;
    color: var(--name-color);
    text-shadow:
        0 0 3px var(--text-shadow-color),
        2px 0 3px var(--text-shadow-color),
        2px 2px 3px var(--text-shadow-color),
        0 2px 3px var(--text-shadow-color),
        -2px 2px 3px var(--text-shadow-color),
        -2px 0 3px var(--text-shadow-color),
        -2px -2px 3px var(--text-shadow-color),
        0 -2px 3px var(--text-shadow-color),
        2px -2px 3px var(--text-shadow-color);
}

a.kitty > .info {
    bottom: 0;
    right: 0;
    color: var(--info-color);
    text-shadow:
        0 0 3px var(--text-shadow-color),
        2px 0 3px var(--text-shadow-color),
        2px 2px 3px var(--text-shadow-color),
        0 2px 3px var(--text-shadow-color),
        -2px 2px 3px var(--text-shadow-color),
        -2px 0 3px var(--text-shadow-color),
        -2px -2px 3px var(--text-shadow-color),
        0 -2px 3px var(--text-shadow-color),
        2px -2px 3px var(--text-shadow-color);
}

a.kitty:hover {
    --hover-color: rgba(175, 225, 255, 0.75);
    z-index: 5000;
    background: var(--hover-color);
    box-shadow: 0 0 6px 6px var(--hover-color);
}
</style>


<!-- inline module shim -->
<!-- this is a goofy hack, but external modules don't work
     in file:// URLs, and I'd like this to work locally. -->
<script type="module" data-info="https://stackoverflow.com/a/43834063">let l,e,t
='script',p=/(from\s+|import\s+)['"](#[\w\-]+)['"]/g,x='textContent',d=document,
s,o;for(o of d.querySelectorAll(t+'[type=inline-module]'))l=d.createElement(t),o
.id?l.id=o.id:0,l.type='module',l[x]=o[x].replace(p,(u,a,z)=>(e=d.querySelector(
t+z+'[type=module][src]'))?a+`/* ${z} */'${e.src}'`:u),l.src=URL.createObjectURL
(new Blob([l[x]],{type:'application/java'+t})),o.replaceWith(l)//inline</script>


<!-- dom utils -->
<script type="inline-module" id="dom">
export const el = (tagNamesString, ...childrenAndAttributes) => {
    let outer, inner;
    if (!tagNamesString) {
        // If the user tries to set attributes on this, should be an error.
        outer = inner = document.createDocumentFragment();
    } else {
        const tagNames = tagNamesString.split(' ');
        outer = inner = document.createElement(tagNames[0]);
        for (const innerTagName of tagNames.slice(1)) {
            const newInner = document.createElement(innerTagName);
            inner.appendChild(newInner);
            inner = newInner;
        }
    }

    addToElement(inner, childrenAndAttributes);

    return outer;
};

el.setChildren = (parent, ...children) => {
    const newContents = el('', ...children);
    parent.textContent = '';
    parent.appendChild(newContents);
};

el.TO_EL = Symbol('el.TO_EL');

const addToElement = (element, additions, before) => {
    if (before) element = before.parentElement; // hacky fix for documentfragment parents and promises

    for (const childOrAttributes of additions) {
        if (Array.isArray(childOrAttributes)) {
            addToElement(element, childOrAttributes, before);
        } else if (childOrAttributes instanceof Node) {
            element.insertBefore(childOrAttributes, before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes[el.TO_EL] == 'function'
        ) {
            const additions = el('', childOrAttributes[el.TO_EL]());
            addToElement(element, [additions], before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes.then == 'function'
        ) {
            const placeholder = document.createElement('progress');
            placeholder.title = 'pending';
            placeholder.promise = childOrAttributes;
            placeholder.style.width = '1em';
            placeholder.style.height = '1em';
            element.insertBefore(placeholder, before);
            childOrAttributes.then(additions => {
                placeholder.style.display = 'none';
                placeholder.value = 1;
                placeholder.title = 'resolved';
                addToElement(element, [additions], placeholder)
            }, error => {
                placeholder.style.border = '.5em double red';
                placeholder.value = 0;
                placeholder.title = `${error && error.stack || error || 'Error'}`;
                console.error(error);
            });
        } else if (typeof childOrAttributes == 'object') {
            if (!(element instanceof Element)) {
                throw new Error("el() cannot define attributes without an element type.");
            }
            for (const key of Object.keys(childOrAttributes)) {
                element.setAttribute(key, childOrAttributes[key]);
            }
        } else if (childOrAttributes != null) {
            element.insertBefore(document.createTextNode(String(childOrAttributes)), before);
        }
    }
};
</script>


<!-- async utils -->
<script type="inline-module" id="async">
export class Throttle {
    constructor(minInterval = 1000) {
        this.minInterval = minInterval;
        this.next = Promise.resolve();
    }

    async tick() {
        const current = this.next;
        this.next = current.then(_ => new Promise(r => setTimeout(r, this.minInterval)));
        return current;
    }
}
</script>


<!-- local cryptokittydex data API -->
<script type="inline-module" id="cryptokittydex">
import {Throttle} from '#async';


export class CryptoKittyDex {
    constructor() {
        this.apiThrottle_ = new Throttle(256);
        this.genes_ = (async () => {
            await this.apiThrottle_.tick();
            const response = await fetch('./cryptokittydex/genes.txt');
            if (response.status !== 200) {
                console.error(response);
                throw new Error("bad response from server");
            }
            return await response.text();
        })();
    }

    async abridgedGene(kittyId) {
        const genes = await this.genes_;
        const geneRecordLength = 25;
        const result = genes.slice(geneRecordLength * kittyId, geneRecordLength * (kittyId + 1) - 1);
        if (result === '+0/l/I/O/0/0+l+I+O+0+I/I') {
            throw new Error(`kitty ID ${kittyId} explicitly does not exist in our genetic data set`);
        } else if (result === '') {
            result = '';
            console.warn(`kitty ID ${kittyId} is out of bounds of our genetic data set!`);
        }
        return result
            .replace(/l/g, '₁')
            .replace(/I/g, '₂')
            .replace(/O/g, '₃')
            .replace(/0/g, '₄');
    }
}

export const cryptokittydex = new CryptoKittyDex();
export default cryptokittydex;
</script>

<!-- cryptokitties API -->
<script type="inline-module" id="cryptokitties">
import {Throttle} from '#async';

export class CryptoKitties {
    constructor() {
        this.apiRoot_ = 'https://api.cryptokitties.co/';
        this.apiThrottle_ = new Throttle(256);
    }

    async json_(path) {
        await this.apiThrottle_.tick();
        const response = await fetch(this.apiRoot_ + path);
        if (!response.ok) {
            throw new Error("non-ok response from cryptokitties API");
        }
        const json = await response.json();
        return json;
    }

    async *kittyIds(ownerAddress='', search='', offset=0, limit=Infinity) {
        const kitties = [];
        for (;;) {
            const page = await this.kitties_(
                ownerAddress, offset + kitties.length, Math.min(100, limit - kitties.length), false, search);

            for (const kitty of page.kitties) {
                kitties.push(kitty);
                yield kitty.id;
            }

            if (kitties.length >= limit) {
                // reached limit
                break;
            }

            if (kitties.length >= page.kitties.total) {
                // last page
                break;
            }

            if (page.kitties.length === 0) {
                // past last page
                break;
            }
        }
    }

    async kitties_(ownerAddress='', offset=0, limit=100, parents=false, search='') {
        return this.json_(`kitties?owner_wallet_address=${ownerAddress}&offset=${offset}&limit=${limit}&parents=${parents}&search=${search}`);
    }

    async kitty(kittyId) {
        return this.json_(`kitties/${kittyId}`);
    }
};

export const cryptokitties = new CryptoKitties();
export default cryptokitties;

export class Kitty {
    constructor() {
        this.id = -1;
        this.name = '⚠ uninitialized ⚠';
        this.generation = -1;
        this.children = null;
        this.matron = null;
        this.sire = null;
    }

    static async fetch(kittyId) {
        const key = `Kitty/${kittyId}`;
        let data = null;

        for (const stored of [
            Kitty.cache.get(key),
            window.sessionStorage.getItem(key), 
            window.localStorage.getItem(key), 
        ]) {
            if (!stored) {
                continue;
            }

            const {data: storedData, timestamp} = JSON.parse(stored);
            if (Date.now() < timestamp + 1000 * 32) {
                data = storedData;
                break;
            }
        }

        if (!data) {
            data = await cryptokitties.kitty(kittyId);

            const storable = JSON.stringify({
                data: data,
                timestamp: Date.now() + Math.random() * 1000 * 512,
            });

            Kitty.cache.set(key, storable);
            try {
                localStorage.setItem(key, storable);
            } catch (ex) {
                console.error(ex);
                console.error("clearing localStorage");
                localStorage.clear();
            }
            try {
                sessionStorage.setItem(key, storable);
            } catch (ex) {
                console.error(ex);
                console.error("clearing sessionStorage");
                sessionStorage.clear();
            }
        }
        
        return Object.assign(new Kitty(), data);
    }

    get owner_wallet_address() {
        return this.owner && this.owner.address;
    }

    get owner_name() {
        return this.owner && this.owner.nickname;
    }
    
    get parent_ids() {
        const ids = [];
        if (this.matron) ids.push(this.matron.id);
        if (this.sire) ids.push(this.sire.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }
    
    get child_ids() {
        const ids = this.children.map(kitty => kitty.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }
}

Kitty.cache = new Map();
</script>


<!-- our logic -->
<script type="inline-module" id="tree">
import {el} from '#dom';
import {cryptokitties, Kitty} from '#cryptokitties';
import {cryptokittydex} from '#cryptokittydex';

const form = document.querySelector('form#family');
const ownerAddressEl = form.querySelector('[name=owner-address]');
const output = document.querySelector('#output');

export const main = async () => {
    if (location.search.match(/^\?owner\-address=.+$/)) {
        let targetId = '';
        if (location.hash > '#') {
            targetId = location.hash.slice(1);
            if (document.getElementById(targetId)) {
                // it already exists, so we don't actually need to handle it
                targetId = null;
            }
        }

        const ownerAddress = decodeURIComponent(location.search.slice('?owner-address='.length));

        ownerAddressEl.value = ownerAddress;

        if (ownerAddress) {
            form.textContent = '';

            const kittyIds = [];
            let r, p = new Promise(resolve => { r = resolve });
            form.appendChild(el('p', p, ` kitties owned by `, el('code', ownerAddress), ':'));

            for await (const kittyId of cryptokitties.kittyIds(ownerAddress)) {
                kittyIds.push(kittyId);
            }
            r(` ${kittyIds.length} `);

            let s, t = new Promise(resolve => { s = resolve });
            form.appendChild(el('div', t))
            const kitties = await Promise.all(kittyIds.map(id => Kitty.fetch(id)));
            kitties.sort((a, b) => {
                if (a.generation < b.generation)
                    return -1;
                else if (a.generation > b.generation)
                    return +1;
                else if (a.id < b.id)
                    return -1;
                else
                    return +1;
            });
            s('');

            for (const kitty of kitties) {
                if (kitty.owner_wallet_address != ownerAddress) {
                    // it's on sale, which we count as not-owned. don't display.
                    continue;
                }

                const tree = makeTree(kitty);
                output.appendChild(el('', tree));
                await tree;

                if (document.getElementById(targetId)) {
                    location.hash = '';
                    location.hash = targetId;
                    targetId = null;
                }
            }
        }
    }
};

const renderedIds = new Set();

const makeTree = async (kitty, rootKitty = kitty) => {
    const renderKitty = (kitty, asSpouse=false) => {
        let className = 'kitty';
        let href =`https://www.cryptokitties.co/kitty/${kitty.id}`;

        const unrelated = kitty.owner_wallet_address !== rootKitty.owner_wallet_address;

        // BUG: assiging IDs to kitties when they appear in a spouse position messes
        //      things up if they're not monogamous.
        let id = '';

        if (unrelated) {
            className += ' unrelated';
        } else if (asSpouse) {
            // related spouses should link to their primary location,
            // even if it's lower-down.
            href = `#/kitty/${kitty.id}`;
            className += ' repeated';
        } else if (renderedIds.has(kitty.id)) {
            href = `#/kitty/${kitty.id}`;
            className += ' repeated';
        } else {
            id = `/kitty/${kitty.id}`;
            renderedIds.add(kitty.id);
        }

        return el(
            'a',
            {
                id: id,
                class: className,
                href: href
            },
            el(
                'img',
                {
                    src: kitty.image_url
                }
            ),
            el('span', {class: 'info'}, `k${kitty.id} g${kitty.generation} c${kitty.children.length}`),
            kitty.name ? el('span', {class: 'name'}, kitty.name) : '',
            el('span', {class: 'gene'}, cryptokittydex.abridgedGene(kitty.id).then(s => {
                const i = Math.floor(s.length / 2);
                return [s.slice(0, i), el('br'), s.slice(i)]
            })),
        );
    };

    const children = await Promise.all(kitty.child_ids.map(id => Kitty.fetch(id)));
    const partner_ids = new Set();
    for (const child of children) {
        for (const parentId of child.parent_ids) {
            partner_ids.add(parentId);
        }
    }
    partner_ids.delete(kitty.id);

    const partners = await Promise.all([...partner_ids].sort().map(id => Kitty.fetch(id)));

    const unrelated = kitty.owner_wallet_address !== rootKitty.owner_wallet_address;
    const id = `/kitty/${kitty.id}`;
    const existing = renderedIds.has(kitty.id);

    if (kitty == rootKitty && existing) {
        return el('');
    } else if (unrelated || partners.length == 0 || existing) {
        // no children. easy.
        return el('p', renderKitty(kitty));
    } else if (partners.length == 1) {
        // monogamy. easy!
        return el('p', renderKitty(kitty), ' + ', renderKitty(partners[0], true), el('ul', await Promise.all(children.map(async (child) => el('li', await makeTree(child, rootKitty))))));
    } else {
        // polygamy. easy?
        return el('p', renderKitty(kitty),
            el('div', {class: 'poly'}, Promise.all(partners.map(async (partner) => el(
                'p', '+ ', renderKitty(partner, true),
                el('ul', await Promise.all(children.filter(child => child.parent_ids.includes(partner.id)).map(async (child) => el('li', await makeTree(child, rootKitty))))))))));
    }
};
</script>


<!-- entry point -->
<script type="inline-module">
import { Kitty } from '#cryptokitties';
import { main } from '#tree';

setTimeout(main);

window.Kitty = Kitty;
</script>
