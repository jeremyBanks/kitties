<!doctype html>

<!-- styles -->
<style>
body {
    font-family: Verdana, sans-serif;
    margin: 32px;
}

input, button {
    font: inherit;
    padding: 2px 6px;
}

a {
    text-decoration: none;
    color: inherit;
}

p, ol, ul, li {
    margin: 0;
}

ul {
    margin-left: 4px;
    margin-bottom: 8px;
    border-left: 1px solid black;
    list-style-type: square;
    padding-left: 16px;
}

li {
    padding: 2px;
}

form {
    margin-bottom: 32px;
}

.Kitty {
    width: 256px;
    display: inline-block;
    padding: .166em;
    border-radius: .166em;
    color: black;
    background: #FFE;
    border: 1px solid #444;
    padding-right: .666em;
    height: 2.666em;
    vertical-align: middle;
    transition: all .1s ease-in-out;
    position: relative;
    z-index: 100;
}

    .Kitty:hover {
        background: #EEF;
        text-shadow:
            #EEF -1px -1px 2px,
            #EEF 1px -1px 2px,
            #EEF 0 0 3px,
            #EEF 1px -1px 2px,
            #EEF 1px 1px 2px;
    }

    .unrelated .Kitty {
        background: #CCC;
    }

        .unrelated .Kitty:hover {
            background: #A9C;
            text-shadow:
                #A9C -1px -1px 2px,
                #A9C 1px -1px 2px,
                #A9C 0 0 3px,
                #A9C 1px -1px 2px,
                #A9C 1px 1px 2px;
        }

    .Kitty img {
        vertical-align: -2em;
        width: 3.833em;
        height: 3.833em;
        position: relative;
        top: -.666em;
        left: -.666em;
        margin-right: -.666em;
        transition: all .1s ease-in-out;
        pointer-events: none;
        position: relative;
        z-index: 200;
    }
    
        .Kitty:hover img {
            transform: translate(192px, -48px) scale(4.0);
        }
    
    .Kitty span {
        position: relative;
        z-index: 300;
    }
</style>


<!-- layout -->
<main>
    <form id="family">
        <p>
            <label>Ancestor Kitty ID(s): <input name="kitty-id" placeholder='123, 4567' /></label>
            <button type="submit">Show</button>
        </p>
    </form>

    <div id="output">

    </div>
</main>


<!-- inline module shim -->
<script type="module" data-info="https://stackoverflow.com/a/43834063">let l,e,t
='script',p=/(from\s+|import\s+)['"](#[\w\-]+)['"]/g,x='textContent',d=document,
s,o;for(o of d.querySelectorAll(t+'[type=inline-module]'))l=d.createElement(t),o
.id?l.id=o.id:0,l.type='module',l[x]=o[x].replace(p,(u,a,z)=>(e=d.querySelector(
t+z+'[type=module][src]'))?a+`/* ${z} */'${e.src}'`:u),l.src=URL.createObjectURL
(new Blob([l[x]],{type:'application/java'+t})),o.replaceWith(l)//inline</script>


<!-- generic utils -->
<script type="inline-module" id="utils">
export const el = (tagNamesString, ...childrenAndAttributes) => {
    let outer, inner;
    if (!tagNamesString) {
        // If the user tries to set attributes on this, should be an error.
        outer = inner = document.createDocumentFragment();
    } else {
        const tagNames = tagNamesString.split(' ');
        outer = inner = document.createElement(tagNames[0]);
        for (const innerTagName of tagNames.slice(1)) {
            const newInner = document.createElement(innerTagName);
            inner.appendChild(newInner);
            inner = newInner;
        }
    }

    addToElement(inner, childrenAndAttributes);

    return outer;
};

el.setChildren = (parent, ...children) => {
    const newContents = el('', ...children);
    parent.textContent = '';
    parent.appendChild(newContents);
};

el.TO_EL = Symbol('el.TO_EL');

const addToElement = (element, additions, before) => {
    if (before) element = before.parentElement; // hacky fix for documentfragment parents and promises

    for (const childOrAttributes of additions) {
        if (Array.isArray(childOrAttributes)) {
            addToElement(element, childOrAttributes, before);
        } else if (childOrAttributes instanceof Node) {
            element.insertBefore(childOrAttributes, before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes[el.TO_EL] == 'function'
        ) {
            const additions = el('', childOrAttributes[el.TO_EL]());
            addToElement(element, [additions], before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes.then == 'function'
        ) {
            const placeholder = document.createComment(' Promise pending. ');
            element.insertBefore(placeholder, before);
            childOrAttributes.then(additions => {
                placeholder.textContent = ' Promise resolved. ';
                addToElement(element, [additions], placeholder)
            }, error => {
                placeholder.textContent = ` Promise rejected: ${error && error.stack || error} `;
                console.error(error);
            });
        } else if (typeof childOrAttributes == 'object') {
            if (!(element instanceof Element)) {
                throw new Error("el() cannot define attributes without an element type.");
            }
            for (const key of Object.keys(childOrAttributes)) {
                element.setAttribute(key, childOrAttributes[key]);
            }
        } else if (childOrAttributes != null) {
            element.insertBefore(document.createTextNode(String(childOrAttributes)), before);
        }
    }
};

export class Throttle {
    constructor(minInterval = 1000) {
        this.minInterval = minInterval;
        this.next = Promise.resolve();
    }

    async tick() {
        const current = this.next;
        this.next = current.then(_ => new Promise(r => setTimeout(r, this.minInterval)));
        return current;
    }
}
</script>


<!-- kitty logic -->
<script type="inline-module" id="kittycodez">
import {el, Throttle} from '#utils';

const form = document.querySelector('form#family');
const kittyIdEl = form.querySelector('[name=kitty-id]');
const output = document.querySelector('#output');

export const main = async () => {
    if (location.search.match(/^\?kitty\-id=.+$/)) {
        const kittyId = decodeURIComponent(location.search.slice('?kitty-id='.length));

        kittyIdEl.value = kittyId;

        for (const id of kittyId.split(/[^0-9]+/g).filter(Boolean).map(Number)) {
            output.appendChild(el('', Kitty.fetch(id).then(kitty => makeTree(kitty))));
        }
    }
};

const makeTree = async (kitty, rootKitty = kitty) => {
    const renderKitty = (kitty) => {
        if (kitty.owner_wallet_address !== rootKitty.owner_wallet_address) {
            return el('span', {class: 'unrelated'}, kitty);
        } else {
            return kitty; // it can render itself
        }
    };

    const children = await Promise.all(kitty.child_ids.map(id => Kitty.fetch(id)));
    const partner_ids = new Set();
    for (const kitty of children) {
        partner_ids.add(...kitty.parent_ids);
    }
    partner_ids.delete(kitty.id);

    const partners = await Promise.all([...partner_ids].sort().map(id => Kitty.fetch(id)));

    if (partners.length == 0) {
        // no children. easy.
        return el('p', renderKitty(kitty));
    } else if (partners.length == 1) {
        // monogamy. easy!
        return el('p', renderKitty(kitty), ' + ', renderKitty(partners[0]), el('ul', children.map(child => el('li', makeTree(child, rootKitty)))));
    } else {
        // polygamy. easy?
        return el('p', renderKitty(kitty),
            partners.map(partner => el(
                'p', '+ ', renderKitty(partner),
                el('ul', children.filter(child => child.parent_ids.includes(partner.id)).map(child => el('li', makeTree(child, rootKitty)))))));
    }
};

const apiThrottle = new Throttle(256);

export class Kitty {
    constructor() {
        this.id = -1;
        this.name = '⚠ uninitialized ⚠';
        this.generation = -1;
        this.children = [{id: -1}];
        this.matron = {id: -1};
        this.sire = {id: -1};
    }

    static async fetch(kittyId) {
        const key = `Kitty/${kittyId}`;
        let data = null;

        for (const stored of [
            Kitty.cache.get(key),
            window.localStorage.getItem(key), 
        ]) {
            if (!stored) {
                continue;
            }

            const {data: storedData, timestamp} = JSON.parse(stored);
            if (Date.now() < timestamp + 1000 * 32) {
                data = storedData;
                break;
            }
        }

        if (!data) {
            await apiThrottle.tick();
            const response = await fetch(`https://api.cryptokitties.co/kitties/${kittyId}`);
            if (!response.ok) throw new Error("non-ok response from cryptokitties API");
            data = await response.json();

            const storable = JSON.stringify({
                data: data,
                timestamp: Date.now() + Math.random() * 1000 * 512,
            });

            Kitty.cache.set(key, storable);
            try {
                localStorage.setItem(key, storable);
            } catch (ex) {
                console.error(ex);
                console.error("clearing localStorage");
                localStorage.clear();
            }
        }
        
        return Object.assign(new Kitty, data);
    }

    get owner_wallet_address() {
        return this.owner && this.owner.address;
    }

    get owner_name() {
        return this.owner && this.owner.nickname;
    }
    
    get parent_ids() {
        const ids = [];
        if (this.matron) ids.push(this.matron.id);
        if (this.sire) ids.push(this.sire.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }
    
    get child_ids() {
        const ids = this.children.map(kitty => kitty.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }

    async [el.TO_EL]() {
        return el(
            'a',
            {
                class: 'Kitty',
                href: `https://www.cryptokitties.co/kitty/${this.id}`
            },
            el(
                'img',
                {
                    src: this.image_url
                }
            ),
            el(
                'span',
                `${this.name || `Kitty #${this.id}`}`
            )
        );
    }
}

Kitty.cache = new Map();
</script>


<!-- entry point -->
<script type="inline-module">
import { main, Kitty } from '#kittycodez';

setTimeout(main);

window.Kitty = Kitty;
</script>
