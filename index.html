<!doctype html>

<title>CryptoKitty Family Trees</title>

<link rel="icon" href="data:,">

<main>
    <form id="family" action="?#">
        <h2>What kitties?</h2>

        <p>
            <label><span>Owner Address or<br />Root Kitty IDs:</span>
            <input name="kitties" placeholder="0x6a5c06692b34e9e5f7a... or 1234, 2567, 3846" value="0x6a5c06692b34e9e5f7af8bbc6463c4add1459f1c" /></label>
        </p>

        <h2>What options?</h2>

        <p>
            <label><span>Target Kai Genome:</span> <input name="target-kai" placeholder="9bb9787747f4gbbg61115837fb9b2b72878j3346fgfdaccc" value="" /></label>
        </p>
        
        <br />

        <p>
            <label><span></span> <button type="submit">Show Me The Kitties!!</button></label>
        </p>

        <br />
    </form>

    <h2>The kitties!</h3>

    <div id="output"></div>
</main>


<!-- styles -->
<style>
h2 {
    padding-left: 128px;
}

body {
    font-family: Verdana, sans-serif;
    margin: 32px;
    margin-bottom: 512px;
}

progress {
    width: 1em;
    height: 1em;
}

input, button, label {
    font-family: monospace;
    padding: 2px 6px;
}

button {
    font-weight: bold;
}

label span {
    display: inline-block;
    text-align: right;
    width: 15em;
}

input {
    width: 92ex;
}

p, ol, ul, li {
    margin: 0;
}

form p + p {
    margin-top: 4px;
}

ul {
    margin-left: 128px;
    margin-bottom: 8px;
    border-left: 1px solid black;
    list-style-type: square;
    padding-left: 16px;
}

li {
    padding: 2px;
}

form {
    margin-bottom: 32px;
}

.poly {
    border-left: 1px dashed black;
}

a.kitty > span.gene {
    font: 12px Consolas, monospace;
    font-weight: bold;
    text-align: right;
    left: auto;
    top: 50px;
    right: 8px;
    bottom: auto;
}

span.gene-1 {
    opacity: 0.25;
}

span.gene-2 {
    opacity: 0.5;
}

span.gene-3 {
    opacity: 0.75;
}

span.gene-4 {
    opacity: 1.0;
    color: #8FC;
    text-shadow: 0 0 2px black, 0 0 3px black, 0 0 4px black, -2px -2px 12px black, -6px -6px 14px black;
    text-shadow: inherit, 0 0 3px yellow;
}

a.kitty {
    animation-name: appear;
    animation-duration: 0.5s;
    border-bottom: 1px solid black;
    margin-right: -16px;
    margin-left: -18px;
}
@keyframes appear {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

a.kitty > img {
    animation-name: appear-fancy;
    animation-duration: 0.5s;

}
@keyframes appear-fancy {
    0% {
        transform: scale(0);
    }
    50% {
        transform: scale(0);
    }
    75% {
        transform: scale(1);
    }
}


a.kitty:target > img {
    transform: scale(4) translate(117px, 64px);
    background: rgba(255, 255, 0, 0.125);
    border: 4px solid rgba(255, 255, 0, 0.75);
}



a.kitty {
    --kitty-size: 192px;
    --text-size: calc(var(--kitty-size) / 16);
    --name-color: black;
    --info-color: #444;
    --text-shadow-color: rgba(255, 255, 255, 0.5);

    display: inline-block;
    position: relative;
    vertical-align: middle;
    box-sizing: border-box;
    width: calc(var(--kitty-size) * 12/16);
    height: calc(var(--kitty-size) * 10/16);

    text-decoration: none;
    color: var(--text-color);
    font: var(--text-size) monospace;
    user-select: all;
}

a.kitty.repeated > * {
    --name-color: royalblue;
    --info-color: royalblue;
}
a.kitty.repeated > img {
    opacity: 0.25;
}
a.kitty.repeated > img {
    opacity: 0.25;
}

a.kitty.unrelated {
    --name-color: brown;
    --info-color: brown;
}
a.kitty.unrelated > img {
    opacity: 0.25;
}

a.kitty:target, a.kitty:active {
    background: rgba(255, 255, 0, 1.0);

}

a.kitty > * {
    display: block;
    position: absolute;
    box-sizing: border-box;
    height: auto;
}

a.kitty > img {
    pointer-events: none;
    width: var(--kitty-size);
    height: var(--kitty-size);
    top: calc(var(--kitty-size) * -3/16);
    left: calc(var(--kitty-size) * -3/16);
}

a.kitty > .name, a.kitty > .gene {
    left: 0;
    font-family: verdana, sans-serif;
    height: auto;
    overflow-wrap: break-word;
    right: calc(var(--text-size));
    bottom: var(--text-size);
    text-align: center;
    font-weight: bold;
    color: var(--name-color);
    text-shadow:
        0 0 3px var(--text-shadow-color),
        2px 0 3px var(--text-shadow-color),
        2px 2px 3px var(--text-shadow-color),
        0 2px 3px var(--text-shadow-color),
        -2px 2px 3px var(--text-shadow-color),
        -2px 0 3px var(--text-shadow-color),
        -2px -2px 3px var(--text-shadow-color),
        0 -2px 3px var(--text-shadow-color),
        2px -2px 3px var(--text-shadow-color);
}

a.kitty > .info {
    bottom: 0;
    right: 0;
    color: var(--info-color);
    text-shadow:
        0 0 3px var(--text-shadow-color),
        2px 0 3px var(--text-shadow-color),
        2px 2px 3px var(--text-shadow-color),
        0 2px 3px var(--text-shadow-color),
        -2px 2px 3px var(--text-shadow-color),
        -2px 0 3px var(--text-shadow-color),
        -2px -2px 3px var(--text-shadow-color),
        0 -2px 3px var(--text-shadow-color),
        2px -2px 3px var(--text-shadow-color);
}

a.kitty:hover {
    --hover-color: rgba(175, 225, 255, 0.75);
    z-index: 5000;
    background: var(--hover-color);
    box-shadow: 0 0 6px 6px var(--hover-color);
}

a[href^="#"] {
    cursor: default;
}
</style>


<!-- inline module shim -->
<!-- this is a goofy hack, but external modules don't work
     in file:// URLs, and I'd like this to work locally. -->
<script type="module" data-info="https://stackoverflow.com/a/43834063">let l,e,t
='script',p=/(from\s+|import\s+)['"](#[\w\-]+)['"]/g,x='textContent',d=document,
s,o;for(o of d.querySelectorAll(t+'[type=inline-module]'))l=d.createElement(t),o
.id?l.id=o.id:0,l.type='module',l[x]=o[x].replace(p,(u,a,z)=>(e=d.querySelector(
t+z+'[type=module][src]'))?a+`/* ${z} */'${e.src}'`:u),l.src=URL.createObjectURL
(new Blob([l[x]],{type:'application/java'+t})),o.replaceWith(l)//inline</script>


<!-- dom utils -->
<script type="inline-module" id="dom">
export const el = (tagNamesString, ...childrenAndAttributes) => {
    let outer, inner;
    if (!tagNamesString) {
        // If the user tries to set attributes on this, should be an error.
        outer = inner = document.createDocumentFragment();
    } else {
        const tagNames = tagNamesString.split(' ');
        outer = inner = document.createElement(tagNames[0]);
        for (const innerTagName of tagNames.slice(1)) {
            const newInner = document.createElement(innerTagName);
            inner.appendChild(newInner);
            inner = newInner;
        }
    }

    addToElement(inner, childrenAndAttributes);

    return outer;
};

el.setChildren = (parent, ...children) => {
    const newContents = el('', ...children);
    parent.textContent = '';
    parent.appendChild(newContents);
};

el.TO_EL = Symbol('el.TO_EL');

const addToElement = (element, additions, before) => {
    if (before) element = before.parentElement; // hacky fix for documentfragment parents and promises

    for (const childOrAttributes of additions) {
        if (Array.isArray(childOrAttributes)) {
            addToElement(element, childOrAttributes, before);
        } else if (childOrAttributes instanceof Node) {
            element.insertBefore(childOrAttributes, before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes[el.TO_EL] == 'function'
        ) {
            const additions = el('', childOrAttributes[el.TO_EL]());
            addToElement(element, [additions], before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes.then == 'function'
        ) {
            const placeholder = document.createElement('progress');
            placeholder.title = 'pending';
            placeholder.promise = childOrAttributes;
            placeholder.style.width = '1em';
            placeholder.style.height = '1em';
            element.insertBefore(placeholder, before);
            childOrAttributes.then(additions => {
                placeholder.style.display = 'none';
                placeholder.value = 1;
                placeholder.title = 'resolved';
                addToElement(element, [additions], placeholder)
            }, error => {
                placeholder.style.border = '.5em double red';
                placeholder.value = 0;
                placeholder.title = `${error && error.stack || error || 'Error'}`;
                console.error(error);
            });
        } else if (typeof childOrAttributes == 'object') {
            if (!(element instanceof Element)) {
                throw new Error("el() cannot define attributes without an element type.");
            }
            for (const key of Object.keys(childOrAttributes)) {
                element.setAttribute(key, childOrAttributes[key]);
            }
        } else if (childOrAttributes != null) {
            element.insertBefore(document.createTextNode(String(childOrAttributes)), before);
        }
    }
};
</script>


<!-- async utils -->
<script type="inline-module" id="async">
export class Throttle {
    constructor(minInterval = 1000) {
        this.minInterval = minInterval;
        this.next = Promise.resolve();
    }

    async tick() {
        const current = this.next;
        this.next = current.then(_ => new Promise(r => setTimeout(r, this.minInterval)));
        return current;
    }
}
</script>


<!-- local cryptokittydex data API -->
<script type="inline-module" id="cryptokittydex">
import {Throttle} from '#async';


export class CryptoKittyDex {
    constructor() {
        this.apiThrottle_ = new Throttle(256);
        this.genes_ = (async () => {
            try {
                await this.apiThrottle_.tick();
                const response = await fetch('./cryptokittydex/genes.js');
                if (response.status !== 200) {
                    console.error(response);
                    throw new Error("bad response from server");
                }
                return await response.text();
            } catch (error) {
                console.error("failed to fetch() genes", error);
            }

            const s = document.createElement('script');
            const loaded = new Promise((resolve, reject) => {
                s.addEventListener('load', resolve, {once: true});
                s.addEventListener('error', reject, {once: true});
            });
            s.src = './cryptokittydex/genes.js';
            document.body.appendChild(s);
            await loaded;
            const lines = window['/genes.js/byLine'];
            if (!lines) {
                throw new Error("genes seemed to load, but are now missing!");
            }
            return lines.map(s => s.padEnd(48)).join('\n');
        })();
    }

    async abridgedGeneome(kittyId, targetKai = null) {
        const geneome = await this.geneome(kittyId);
        let filtered = '';
        for (let i = 0; i < geneome.length; i++) {
            if (!targetKai || geneome[i] == targetKai[i]) {
                filtered += geneome[i];
            } else {
                filtered += ' ';
            }
        }

        const pieces = [];

        for (let i = 0; i < geneome.length / 4; i++) {
            const genes = geneome.slice(i * 4, (i + 1) * 4);
            const filteredGenes = filtered.slice(i * 4, (i + 1) * 4);
            const dominant = genes[3];
            const filteredDominant = filteredGenes[3];
            const count = [...genes].filter(c => c == dominant).length;
            if (filteredDominant != ' ') {
                pieces.push(dominant, '¹²³⁴'[count - 1]);
            } else {
                pieces.push(' ', ' ');
            }
        }

        return pieces.join('');
    }

    async geneome(kittyId) {
        const genes = await this.genes_;
        const geneRecordLength = 48;
        const recordSeparatorLength = 1;
        const stride = geneRecordLength + recordSeparatorLength;
        let result = genes.slice(stride * kittyId, stride * kittyId + geneRecordLength);
        if (result.includes('/')) {
            throw new Error(`kitty ID ${kittyId} is missing from our CryptoKittydex genetic data`);
        } else if (result.length < geneRecordLength) {
            result = '';
            console.warn(`kitty ID ${kittyId} is too new to be in our CryptoKittydex genetic data`);
        }
        return result;
    }
}

export const cryptokittydex = new CryptoKittyDex();
export default cryptokittydex;
</script>

<!-- cryptokitties API -->
<script type="inline-module" id="cryptokitties">
import {Throttle} from '#async';

export class CryptoKitties {
    constructor() {
        this.apiRoot_ = 'https://api.cryptokitties.co/';
        this.apiThrottle_ = new Throttle(256);
    }

    async json_(path) {
        await this.apiThrottle_.tick();
        const response = await fetch(this.apiRoot_ + path);
        if (!response.ok) {
            throw new Error("non-ok response from cryptokitties API");
        }
        const json = await response.json();
        return json;
    }

    async *kittyIds(kittiesInput='', search='', offset=0, limit=Infinity) {
        const kitties = [];
        for (;;) {
            const page = await this.kitties_(
                kittiesInput, offset + kitties.length, Math.min(100, limit - kitties.length), false, search);

            for (const kitty of page.kitties) {
                kitties.push(kitty);
                yield kitty.id;
            }

            if (kitties.length >= limit) {
                // reached limit
                break;
            }

            if (kitties.length >= page.kitties.total) {
                // last page
                break;
            }

            if (page.kitties.length === 0) {
                // past last page
                break;
            }
        }
    }

    async kitties_(kittiesInput='', offset=0, limit=100, parents=false, search='') {
        return this.json_(`kitties?owner_wallet_address=${kittiesInput}&offset=${offset}&limit=${limit}&parents=${parents}&search=${search}`);
    }

    async kitty(kittyId) {
        return this.json_(`kitties/${kittyId}`);
    }
};

export const cryptokitties = new CryptoKitties();
export default cryptokitties;

export class Kitty {
    constructor() {
        this.id = -1;
        this.name = '⚠ uninitialized ⚠';
        this.generation = -1;
        this.children = null;
        this.matron = null;
        this.sire = null;
    }

    static async fetch(kittyId) {
        const key = `Kitty/${kittyId}`;
        let data = null;

        let gotNewData;
        const newData = new Promise(resolve => { gotNewData = resolve });

        let dataIsStale = false;

        for (let stored of [
            Kitty.cache.get(key),
            window.sessionStorage.getItem(key), 
            window.localStorage.getItem(key), 
        ]) {
            if (!stored) {
                continue;
            }

            stored = await stored;

            const {data: storedData, staleAt, deletedAt} = JSON.parse(stored);
            if (!(storedData && staleAt && deletedAt)) deletedAt = 0;
            if (Date.now() < deletedAt) {
                if (staleAt < Date.now()) {
                    dataIsStale = true;
                }
                data = storedData;
                break;
            }
        }

        if (!data || dataIsStale) {
            gotNewData((async () => {
                // hack to block duplicate requests
                Kitty.cache.set(key, newData.then(_ => Kitty.cache.get(key)));

                const data = await cryptokitties.kitty(kittyId);

                const storable = JSON.stringify({
                    data: data,
                    staleAt: Date.now() + (0.25 + 0.75 * Math.random()) * 1000 * 60 * 30, // 7.5-30 minutes 
                    deletedAt: Date.now() + 1000 * 60 * 60 * 24 * 7, // one week
                });
    
                Kitty.cache.set(key, storable);
                try {
                    localStorage.setItem(key, storable);
                } catch (ex) {
                    console.error(ex);
                    console.error("clearing localStorage");
                    localStorage.clear();
                }
                try {
                    sessionStorage.setItem(key, storable);
                } catch (ex) {
                    console.error(ex);
                    console.error("clearing sessionStorage");
                    sessionStorage.clear();
                }

                return data;
            })());

            if (!data) {
                data = await newData;
            }
        }
        
        return Object.assign(new Kitty(), data);
    }

    get owner_wallet_address() {
        return this.owner && this.owner.address;
    }

    get owner_name() {
        return this.owner && this.owner.nickname;
    }
    
    get parent_ids() {
        const ids = [];
        if (this.matron) ids.push(this.matron.id);
        if (this.sire) ids.push(this.sire.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }
    
    get child_ids() {
        const ids = this.children.map(kitty => kitty.id);
        ids.sort((a, b) => (a - b));
        return ids;
    }

    get autoName() {
      const abr = (s, l=3) => {
        const frequency = Array.from('etaoinsrhdlucmfywgpbvkxqjz');
        while (s.length > l && frequency.length > 0) {
          let c = frequency.shift();
          while (s.length > l) {
            let i = s.lastIndexOf(c);
            if (i > 0) {
              s = s.slice(0, i) + s.slice(i + 1);
            } else break; 
          }
        }
        return s.slice(0, l);
      }
      const tc = s => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase()
      return this.cattributes.map(x => `${abr(x.type, 2)}${tc(abr(x.description, 3))}`).sort().join(' '));
    }
}

Kitty.cache = new Map();
</script>


<!-- our logic -->
<script type="inline-module" id="tree">
import {el} from '#dom';
import {cryptokitties, Kitty} from '#cryptokitties';
import {cryptokittydex} from '#cryptokittydex';

const form = document.querySelector('form#family');
const kittiesInputEl = form.querySelector('[name=kitties]');
const targetKaiEl = form.querySelector('[name=target-kai]');
const output = document.querySelector('#output');

let targetKai = null;

export const main = async () => {
    const params = new URLSearchParams(location.search);
    let kittiesInput = params.get('kitties') || '';
    targetKai = params.get('target-kai') || '';

    kittiesInputEl.value = kittiesInput;
    targetKaiEl.value = targetKai;

    const comments = /(^[^:]*:|#.+|\s*\([^\)]*\)\s*)/g
    kittiesInput = kittiesInput.replace(comments, '').trim();
    targetKai = targetKai.replace(comments, '').replace(/\s+/g, '');

    if (kittiesInput) {
        let targetId = '';
        if (location.hash > '#') {
            targetId = location.hash.slice(1);
            if (document.getElementById(targetId)) {
                // it already exists, so we don't actually need to handle it
                targetId = null;
            }
        }

        const kittyIds = [];

        if (/^0x[0-9A-Fa-f]+$/.test(kittiesInput)) {
            // it's an address
            let r, p = new Promise(resolve => { r = resolve });
            form.appendChild(el('p', p, ` kitties owned by `, el('code', kittiesInput), ':'));

            for await (const kittyId of cryptokitties.kittyIds(kittiesInput)) {
                kittyIds.push(kittyId);
            }
            r(` ${kittyIds.length} `);
        } else {
            // assume it's a list of kitty IDs
            kittyIds.push(...kittiesInput.split(/[^0-9\-\.\+]+/).filter(Boolean).map(Number));
        }

        if (kittyIds.length == 0) {
            console.log("no kitties specifies, returning.");
            return;
        } else {
            console.debug("kitty IDs:", kittyIds);
        }

        let s, t = new Promise(resolve => { s = resolve });
        form.appendChild(el('div', t))
        const kitties = await Promise.all(kittyIds.map(id => Kitty.fetch(id)));
        kitties.sort((a, b) => {
            if (a.generation < b.generation)
                return -1;
            else if (a.generation > b.generation)
                return +1;
            else if (a.id < b.id)
                return -1;
            else
                return +1;
        });
        s('');

        for (const kitty of kitties) {
            const tree = makeTree(kitty);
            output.appendChild(el('', tree));
            await tree;

            if (document.getElementById(targetId)) {
                location.hash = '';
                location.hash = targetId;
                targetId = null;
            }
        }
    }
};

const renderedIds = new Set();

const makeTree = async (kitty, rootKitty = kitty) => {
    const renderKitty = (kitty, asSpouse=false) => {
        let className = 'kitty';
        let href =`https://cryptokittydex.com/kitties/${kitty.id}`;

        const unrelated = kitty.owner_wallet_address !== rootKitty.owner_wallet_address;

        let id = '';

        if (unrelated) {
            className += ' unrelated';
        } else if (asSpouse) {
            // related spouses should link to their primary location,
            // even if it's lower-down.
            href = `#kitty-${kitty.id}`;
            className += ' repeated';
        } else if (renderedIds.has(kitty.id)) {
            href = `#kitty-${kitty.id}`;
            className += ' repeated';
        } else {
            // yes, we're linking to ourself.
            href = `#kitty-${kitty.id}`;
            id = `kitty-${kitty.id}`;
            renderedIds.add(kitty.id);
        }

        function f(s) {
            if (s === '₁') return el('span', {class: 'gene-1'}, s);
            if (s === '₂') return el('span', {class: 'gene-2'}, s);
            if (s === '₃') return el('span', {class: 'gene-3'}, s);
            if (s === '₄') return el('span', {class: 'gene-4'}, s);
            return el('span', {class: 'gene-value'}, s);
        }

        return el(
            'a',
            {
                id: id,
                class: className,
                href: href
            },
            el(
                'img',
                {
                    src: kitty.image_url
                }
            ),
            el('span', {class: 'info'}, `k${kitty.id} g${kitty.generation} c${kitty.children.length}`),
            el('span', {class: 'name'}, kitty.name.replace(/[^a-z]+/gi, '') ? kitty.name : kitty.autoName),
            el('span', {class: 'gene', title: "genes"}, cryptokittydex.abridgedGeneome(kitty.id, targetKai).then(s => {
                const i = Math.floor(s.length / 2);
                return [[...s.slice(0, i)].map(f), el('br'), [...s.slice(i)].map(f)]
            })),
        );
    };

    const children = await Promise.all(kitty.child_ids.map(id => Kitty.fetch(id)));
    const partner_ids = new Set();
    for (const child of children) {
        for (const parentId of child.parent_ids) {
            partner_ids.add(parentId);
        }
    }
    partner_ids.delete(kitty.id);

    const partners = await Promise.all([...partner_ids].sort().map(id => Kitty.fetch(id)));

    const unrelated = kitty.owner_wallet_address !== rootKitty.owner_wallet_address;
    const id = `kitty-${kitty.id}`;
    const existing = renderedIds.has(kitty.id);

    if (kitty == rootKitty && existing) {
        return el('');
    } else if (unrelated || partners.length == 0 || existing) {
        // no children. easy.
        return el('p', renderKitty(kitty));
    } else if (partners.length == 1) {
        // monogamy. easy!
        return el('p', renderKitty(kitty), ' + ', renderKitty(partners[0], true), el('ul', await Promise.all(children.map(async (child) => el('li', await makeTree(child, rootKitty))))));
    } else {
        // polygamy. easy?
        return el('p', renderKitty(kitty),
            el('div', {class: 'poly'}, Promise.all(partners.map(async (partner) => el(
                'p', '+ ', renderKitty(partner, true),
                el('ul', await Promise.all(children.filter(child => child.parent_ids.includes(partner.id)).map(async (child) => el('li', await makeTree(child, rootKitty))))))))));
    }
};
</script>


<!-- entry point -->
<script type="inline-module">
import { Kitty } from '#cryptokitties';
import { main } from '#tree';

setTimeout(main);
</script>
