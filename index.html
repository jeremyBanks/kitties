<!doctype html>


<!-- dependencies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/treant-js/1.0/Treant.css" />


<!-- styles -->
<style>
    body {
        max-width: 600px;
        font-family: Verdana, sans-serif;
        margin: 16px;
    }

    input, button {
        font: inherit;
        padding: 2px 6px;
    }

    a {
        text-decoration: none;
        color: inherit;
    }

    .Kitty {
        display: inline-block;
        padding: .166em;
        border-radius: .166em;
        background: #FFE;
        border: 1px solid #444;
        padding-right: .666em;
        height: 2.666em;
        overflow: hidden;
    }

        .Kitty:hover {
            background: #FEE;
        }

        .Kitty img {
            vertical-align: -2em;
            width: 3.833em;
            height: 3.833em;
            position: relative;
            top: -.666em;
            left: -.666em;
            margin-right: -.666em;
        }
</style>


<!-- layout -->
<main>
    <h1>CryptoKitty Family Tree</h1>

    <form id="family">
        <p>
            <label>Ancestor Kitty ID: <input type="number" name="kitty-id" min="1" /></label>
            <button type="submit">Show</button>
        </p>
    </form>

    <div id="output">

    </div>
</main>


<!-- inline module shim -->
<script type="module" data-info="https://stackoverflow.com/a/43834063">let l,e,t
='script',p=/(from\s+|import\s+)['"](#[\w\-]+)['"]/g,x='textContent',d=document,
s,o;for(o of d.querySelectorAll(t+'[type=inline-module]'))l=d.createElement(t),o
.id?l.id=o.id:0,l.type='module',l[x]=o[x].replace(p,(u,a,z)=>(e=d.querySelector(
t+z+'[type=module][src]'))?a+`/* ${z} */'${e.src}'`:u),l.src=URL.createObjectURL
(new Blob([l[x]],{type:'application/java'+t})),o.replaceWith(l)//inline</script>


<!-- generic utils -->
<script type="inline-module" id="utils">
export const el = (tagNamesString, ...childrenAndAttributes) => {
    let outer, inner;
    if (!tagNamesString) {
        // If the user tries to set attributes on this, should be an error.
        outer = inner = document.createDocumentFragment();
    } else {
        const tagNames = tagNamesString.split(' ');
        outer = inner = document.createElement(tagNames[0]);
        for (const innerTagName of tagNames.slice(1)) {
            const newInner = document.createElement(innerTagName);
            inner.appendChild(newInner);
            inner = newInner;
        }
    }

    addToElement(inner, childrenAndAttributes);

    return outer;
};

el.setChildren = (parent, ...children) => {
    const newContents = el('', ...children);
    parent.textContent = '';
    parent.appendChild(newContents);
};

el.TO_EL = Symbol('el.TO_EL');

const addToElement = (element, additions, before) => {
    if (before) element = before.parentElement; // hacky fix for documentfragment parents and promises

    for (const childOrAttributes of additions) {
        if (Array.isArray(childOrAttributes)) {
            addToElement(element, childOrAttributes, before);
        } else if (childOrAttributes instanceof Node) {
            element.insertBefore(childOrAttributes, before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes[el.TO_EL] == 'function'
        ) {
            const additions = el('', childOrAttributes[el.TO_EL]());
            addToElement(element, [additions], before);
        } else if (
            typeof childOrAttributes == 'object' &&
            typeof childOrAttributes.then == 'function'
        ) {
            const placeholder = document.createComment(' Promise pending. ');
            element.insertBefore(placeholder, before);
            childOrAttributes.then(additions => {
                placeholder.textContent = ' Promise resolved. ';
                addToElement(element, [additions], placeholder)
            }, error => {
                placeholder.textContent = ` Promise rejected: ${error && error.stack || error} `;
                console.error(error);
            });
        } else if (typeof childOrAttributes == 'object') {
            if (!(element instanceof Element)) {
                throw new Error("el() cannot define attributes without an element type.");
            }
            for (const key of Object.keys(childOrAttributes)) {
                element.setAttribute(key, childOrAttributes[key]);
            }
        } else if (childOrAttributes != null) {
            element.insertBefore(document.createTextNode(String(childOrAttributes)), before);
        }
    }
};

export class Throttle {
    constructor(minInterval = 1000) {
        this.minInterval = minInterval;
        this.next = Promise.resolve();
    }

    async tick() {
        const current = this.next;
        this.next = current.then(_ => new Promise(r => setTimeout(r, this.minInterval)));
        return current;
    }
}
</script>


<!-- kitty logic -->
<script type="inline-module" id="kittycodez">
import {el, Throttle} from '#utils';

const form = document.querySelector('form#family');
const kittyIdEl = form.querySelector('[name=kitty-id]');
const output = document.querySelector('#output');

export const main = async () => {
    if (location.search.match(/^\?kitty\-id=\d+$/)) {
        const kittyId = Number(location.search.slice('?kitty-id='.length));

        kittyIdEl.value = kittyId;

        showTree(kittyId);
    }
};

const showTree = async (ancestorKittyId) => {
    const rootAncestor = Kitty.fetch(ancestorKittyId);

    el.setChildren(output,
        rootAncestor.then(rootAncestor => el('h2', "Family of ", rootAncestor)),
        rootAncestor.then(rootAncestor => el('div', makeTree(rootAncestor))),
    );
};

const makeTree = async (kitty) => {
    return el('div',
        el('p', kitty),
        el('ul', kitty.fetchChildren().then(children => children.map(child => el('li', makeTree(child))))));
};

const apiThrottle = new Throttle(256);

class Kitty {
    static async fetch(kittyId) {
        const key = `Kitty/${kittyId}`;
        let data = null;

        const stored = window.localStorage.getItem(key);
        if (stored) {
            const {data: storedData, timestamp} = JSON.parse(stored);
            if (Date.now() < timestamp + 60 * 1000) data = storedData;
        }

        if (!data) {
            await apiThrottle.tick();
            const response = await fetch(`https://api.cryptokitties.co/kitties/${kittyId}`);
            if (!response.ok) throw new Error("non-ok response from cryptokitties API");
            data = await response.json();

            window.localStorage.setItem(key, JSON.stringify({
                data: data,
                timestamp: Date.now()
            }));
        }
        
        return Object.assign(new Kitty, data);
    }

    async fetchChildren() {
        return Promise.all(this.children.map(data => Kitty.fetch(data.id)));
    }

    async fetchParents() {
        const parents = [];
        if (this.matron && this.matron.id) {
            parents.push(await Kitty.fetch(this.matron.id));
        }
        if (this.sire && this.sire.id) {
            parents.push(await Kitty.fetch(this.sire.id));
        }
        return parents;
    }

    async [el.TO_EL]() {
        return el(
            'a',
            {
                class: 'Kitty',
                href: `https://www.cryptokitties.co/kitty/${this.id}`
            },
            el(
                'img',
                {
                    src: this.image_url
                }
            ),
            `${this.name}`
        );
    }
}
</script>


<!-- entry point -->
<script type="inline-module">
import { main } from '#kittycodez';

setTimeout(main);
</script>
